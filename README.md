# learning
学无止境
## 一、Zookeeper
#### Zookeeper中的配置文件zoo.cfg中参数含义解读如下：
- 1．tickTime =2000：通信心跳数，Zookeeper服务器与客户端心跳时间，单位毫秒
Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。
它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超时时间是2*tickTime)
- 2．initLimit =10：LF初始通信时限
集群中的Follower跟随者服务器与Leader领导者服务器之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限。
- 3．syncLimit =5：LF同步通信时限
集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer。
- 4．dataDir：数据文件目录+数据持久化路径
主要用于保存Zookeeper中的数据。
- 5．clientPort =2181：客户端连接端口
监听客户端连接的端口。

#### 选举机制（面试重点）
- 1）半数机制：集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。
- 2）Zookeeper虽然在配置文件中并没有指定Leader和Follower。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。
- 3）以一个简单的例子来说明整个选举的过程。
- 假设有五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动
-（1）服务器1启动，此时只有它一台服务器启动了，它发出去的报文没有任何响应，所以它的选举状态一直是LOOKING状态。
- （2）服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以id值较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3)，所以服务器1、2还是继续保持LOOKING状态。
- （3）服务器3启动，根据前面的理论分析，服务器3成为服务器1、2、3中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的Leader。
- （4）服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。
- （5）服务器5启动，同4一样当小弟。

#### ZooKeeper的监听原理是什么

#### ZooKeeper的部署方式有哪几种？集群中的角色有哪些？集群最少需要几台机器？
- （1）部署方式单机模式、集群模式
- （2）角色：Leader和Follower, 还有Observer? 但是Observer不参与选举。
- （3）集群最少需要机器数：3

## 二、Kafka

# 三、Spring
> Spring是一个分层的JavaSE/EEfull-stack(一站式)轻量级开源框架，它针对JavaEE的三层结构，每一层Spring都提供了不同的解决技术。
- WEB层：SpringMVC
- 业务层：Spring的IoC
- 持久层：Spring的JDBCTemplate(Spring的JDBC模板，ORM模板用于整合其他的持久层框架)

Spring的核心有两部分：
- IoC：控制反转
> 举例来说，在之前的操作中，比方说有一个类，我们想要调用类里面的方法(不是静态方法)，就要创建类的对象，使用对象调用方法实现。对于Spring来说，Spring创建对象的过程，不是在代码里面实现的，而是交给Spring来进行配置实现的。
- AOP：面向切面编程

## SpringAOP原理
1. 面向切面编程(也叫面向方面)：Aspect Oriented Programming(AOP),是目前软件开发中的一个热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
2. 主要的功能是：**日志记录，性能统计，安全控制，事务处理，异常处理**等等。

### CGLIB动态代理与JDK动态区别
> java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
Spring中。
1. 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP；
2. 如果目标对象实现了接口，可以强制使用CGLIB实现AOP；
3. 如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换。

- ==JDK动态代理只能对实现了接口的类生成代理，而不能针对类；==
- ==CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。 因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。==

## 事务
### 传播机制
- REQUIRED（默认）：支持使用当前事务，如果当前事务不存在，创建一个新事务。
- SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。
- MANDATORY：中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。
- REQUIRES_NEW：创建一个新事务，如果当前事务存在，把当前事务挂起。
- NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。
- NEVER：无事务执行，如果当前有事务则抛出Exception。
- NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。
> 注解配置时如：@Transactional(propagation=Propagation.REQUIRED) 

### 四种隔离级别

事务隔离级别 | 脏读 | 不可重复读 | 幻读
---|---|---|---
读未提交(Read-Uncommitted) | 是 | 是 | 是
不可重复读(Read-Committed) | 否 | 是 | 是
可重复读(Repeatable-Read) | 否 | 否 | 是
串行化(Serializable) | 否 | 否 | 否
- 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。
- 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
- 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
- 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。




